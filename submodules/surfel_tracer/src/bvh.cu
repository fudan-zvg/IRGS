#include <gtracer/bvh.h>

#include <optix.h>
#include <optix_stubs.h>
#include <optix_function_table_definition.h>
#include <optix_stack_size.h>

// Custom optix toolchain stuff
#include "optix/gaussiantrace_forward.h"
#include "optix/gaussiantrace_backward.h"
#include "optix/gaussiantrace_intersection_test.h"

#include "optix/program.h"

// Compiled optix program PTX generated by cmake and wrapped in a C
// header by bin2c.
namespace optix_ptx {
	#include <optix_ptx.h>
}

#include <stack>
#include <iostream>
#include <cstdio>

using namespace gtracer;


namespace gtracer {

OptixDeviceContext g_optix;

namespace optix {
	bool initialize() {
		static bool ran_before = false;
		static bool is_optix_initialized = false;
		if (ran_before) {
			return is_optix_initialized;
		}

		ran_before = true;

		// Initialize CUDA with a no-op call to the the CUDA runtime API
		CUDA_CHECK_THROW(cudaFree(nullptr));

		try {
			// Initialize the OptiX API, loading all API entry points
			OPTIX_CHECK_THROW(optixInit());

			// Specify options for this context. We will use the default options.
			OptixDeviceContextOptions options = {};

			// Associate a CUDA context (and therefore a specific GPU) with this
			// device context
			CUcontext cuCtx = 0; // NULL means take the current active context

			OPTIX_CHECK_THROW(optixDeviceContextCreate(cuCtx, &options, &g_optix));
		} catch (std::exception& e) {
			return false;
		}

		is_optix_initialized = true;
		return true;
	}

	void destroy(){
		OPTIX_CHECK_THROW(optixDeviceContextDestroy(g_optix));
	}

	class Gas {
	public:
		Gas(const float* triangles, int n_triangles, OptixDeviceContext optix, cudaStream_t stream) {
			// Specify options for the build. We use default options for simplicity.
			accel_options.buildFlags = OPTIX_BUILD_FLAG_ALLOW_UPDATE;
			accel_options.operation = OPTIX_BUILD_OPERATION_BUILD;

			// Populate the build input struct with our triangle data as well as
			// information about the sizes and types of our data
			const uint32_t triangle_input_flags[1] = { OPTIX_GEOMETRY_FLAG_NONE };

			CUdeviceptr d_triangles = (CUdeviceptr)(uintptr_t)triangles;

			triangle_input.type = OPTIX_BUILD_INPUT_TYPE_TRIANGLES;
			triangle_input.triangleArray.vertexFormat = OPTIX_VERTEX_FORMAT_FLOAT3;
			triangle_input.triangleArray.numVertices = (uint32_t)n_triangles*3;
			triangle_input.triangleArray.vertexBuffers = &d_triangles;
			triangle_input.triangleArray.flags = triangle_input_flags;
			triangle_input.triangleArray.numSbtRecords = 1;

			// Query OptiX for the memory requirements for our GAS
			OPTIX_CHECK_THROW(optixAccelComputeMemoryUsage(optix, &accel_options, &triangle_input, 1, &gas_buffer_sizes));

			// Allocate device memory for the scratch space buffer as well
			// as the GAS itself
			gas_tmp_buffer.resize(gas_buffer_sizes.tempSizeInBytes);
			m_gas_gpu_buffer.resize(gas_buffer_sizes.outputSizeInBytes);

			OPTIX_CHECK_THROW(optixAccelBuild(
				optix,
				stream,
				&accel_options,
				&triangle_input,
				1,           // num build inputs
				(CUdeviceptr)(uintptr_t)gas_tmp_buffer.data(),
				gas_buffer_sizes.tempSizeInBytes,
				(CUdeviceptr)(uintptr_t)m_gas_gpu_buffer.data(),
				gas_buffer_sizes.outputSizeInBytes,
				&m_gas_handle, // Output handle to the struct
				nullptr,       // emitted property list
				0              // num emitted properties
			));
		}

		void update(const float* triangles, int n_triangles, OptixDeviceContext optix, cudaStream_t stream) {
			// Specify options for the build. We use default options for simplicity.
			accel_options.operation = OPTIX_BUILD_OPERATION_UPDATE;

			// Populate the build input struct with our triangle data as well as
			// information about the sizes and types of our data
			const uint32_t triangle_input_flags[1] = { OPTIX_GEOMETRY_FLAG_NONE };

			CUdeviceptr d_triangles = (CUdeviceptr)(uintptr_t)triangles;
			triangle_input.triangleArray.vertexBuffers = &d_triangles;
			triangle_input.triangleArray.flags = triangle_input_flags;

			// // Query OptiX for the memory requirements for our GAS
			// OPTIX_CHECK_THROW(optixAccelComputeMemoryUsage(optix, &accel_options, &triangle_input, 1, &gas_buffer_sizes));

			// // Allocate device memory for the scratch space buffer as well
			// // as the GAS itself
			// gas_tmp_buffer.resize(gas_buffer_sizes.tempSizeInBytes);
			// m_gas_gpu_buffer.resize(gas_buffer_sizes.outputSizeInBytes);

			OPTIX_CHECK_THROW(optixAccelBuild(
				optix,
				stream,
				&accel_options,
				&triangle_input,
				1,           // num build inputs
				(CUdeviceptr)(uintptr_t)gas_tmp_buffer.data(),
				gas_buffer_sizes.tempSizeInBytes,
				(CUdeviceptr)(uintptr_t)m_gas_gpu_buffer.data(),
				gas_buffer_sizes.outputSizeInBytes,
				&m_gas_handle, // Output handle to the struct
				nullptr,       // emitted property list
				0              // num emitted properties
			));
		}

		OptixTraversableHandle handle() const {
			return m_gas_handle;
		}

	private:
		OptixTraversableHandle m_gas_handle;
		GPUMemory<char> m_gas_gpu_buffer;
		OptixAccelBuildOptions accel_options = {};
		OptixBuildInput triangle_input = {};
		OptixAccelBufferSizes gas_buffer_sizes;
		GPUMemory<char> gas_tmp_buffer;
	};
}

class TriangleBvh : public TriangleBvhBase {
public:
	TriangleBvh(){
		m_optix.available = optix::initialize();
		m_optix.gaussiantrace_forward = std::make_unique<optix::Program<Gaussiantrace_forward>>((const char*)optix_ptx::gaussiantrace_forward_ptx, sizeof(optix_ptx::gaussiantrace_forward_ptx), g_optix);
		m_optix.gaussiantrace_backward = std::make_unique<optix::Program<Gaussiantrace_backward>>((const char*)optix_ptx::gaussiantrace_backward_ptx, sizeof(optix_ptx::gaussiantrace_backward_ptx), g_optix);
		m_optix.gaussiantrace_intersection_test = std::make_unique<optix::Program<Gaussiantrace_intersection_test>>((const char*)optix_ptx::gaussiantrace_intersection_test_ptx, sizeof(optix_ptx::gaussiantrace_intersection_test_ptx), g_optix);
		// printf("Build OptiX shaders success.\n");
	}

	~TriangleBvh() {
		if (m_optix.available) {
			optix::destroy();
			printf("OptiX destroyed.\n");
		}
	}

    void intersection_test(
		uint32_t n_elements, const glm::vec3* rays_o, const glm::vec3* rays_d, const int* gs_idxs, 
		const glm::vec3* means3D, const float* opacity, const glm::vec3* ru, const glm::vec3* rv, const glm::vec3* normals, bool* intersection, cudaStream_t stream
	) override {
        m_optix.gaussiantrace_intersection_test->invoke(
			{
				rays_o, rays_d, gs_idxs, 
				means3D, opacity, ru, rv, normals, intersection, m_optix.gas->handle()
			}, 
			{n_elements, 1, 1}, 
			stream);
    }

    void gaussian_trace_forward(
		uint32_t n_elements, const int S, const glm::vec3* rays_o, const glm::vec3* rays_d, const int* gs_idxs, 
		const glm::vec3* means3D, const float* opacity, const glm::vec3* ru, const glm::vec3* rv, const glm::vec3* normals, const float* features, const glm::vec3* shs, 
		glm::vec3* color, glm::vec3* normal, float* feature, float* depth, float* alpha, 
		const float alpha_min, const float transmittance_min, const int deg, const int max_coeffs, const bool back_culling, cudaStream_t stream
	) override {
        m_optix.gaussiantrace_forward->invoke(
			{
				rays_o, rays_d, gs_idxs, 
				means3D, opacity, ru, rv, normals, features, shs, 
				color, normal, feature, depth, alpha, 
				alpha_min, transmittance_min, deg, max_coeffs, S, back_culling, m_optix.gas->handle()
			}, 
			{n_elements, 1, 1}, 
			stream);
    }

	void gaussian_trace_backward(
		uint32_t n_elements, const int S, const glm::vec3* rays_o, const glm::vec3* rays_d, const int* gs_idxs, 
		const glm::vec3* means3D, const float* opacity, const glm::vec3* ru, const glm::vec3* rv, const glm::vec3* normals, const float* features, const glm::vec3* shs, 
		const glm::vec3* color, const glm::vec3* normal, const float* feature, const float* depth, const float* alpha, 
		glm::vec3* grad_rays_o, glm::vec3* grad_rays_d, glm::vec3* grad_means3D, float* grad_opacity, glm::vec3* grad_ru, glm::vec3* grad_rv, glm::vec3* grad_normals, float* grad_features, glm::vec3* grad_shs, 
        const glm::vec3* grad_color, const glm::vec3* grad_normal, const float* grad_feature, const float* grad_depth, const float* grad_alpha,
		const float alpha_min, const float transmittance_min, const int deg, const int max_coeffs, const bool back_culling, cudaStream_t stream
	) override {
        m_optix.gaussiantrace_backward->invoke(
			{
				rays_o, rays_d, gs_idxs, 
				means3D, opacity, ru, rv, normals, features, shs, 
				color, normal, feature, depth, alpha, 
				grad_rays_o, grad_rays_d, grad_means3D, grad_opacity, grad_ru, grad_rv, grad_normals, grad_features, grad_shs, 
				grad_color, grad_normal, grad_feature, grad_depth, grad_alpha,
				alpha_min, transmittance_min, deg, max_coeffs, S, back_culling, m_optix.gas->handle()
			}, 
			{n_elements, 1, 1}, 
			stream);
    }

    void build_bvh(const float* triangles, int n_triangles, cudaStream_t stream) override {
		m_optix.gas = std::make_unique<optix::Gas>(triangles, n_triangles, g_optix, stream);
		// printf("Build OptiX GAS success.\n");
    }

    void update_bvh(const float* triangles, int n_triangles, cudaStream_t stream) override {
		m_optix.gas->update(triangles, n_triangles, g_optix, stream);
    }

private:
    struct {
        std::unique_ptr<optix::Gas> gas;
        std::unique_ptr<optix::Program<Gaussiantrace_forward>> gaussiantrace_forward;
        std::unique_ptr<optix::Program<Gaussiantrace_backward>> gaussiantrace_backward;
        std::unique_ptr<optix::Program<Gaussiantrace_intersection_test>> gaussiantrace_intersection_test;
        bool available = false;
    } m_optix;
};

std::unique_ptr<TriangleBvhBase> TriangleBvhBase::make() {
    return std::unique_ptr<TriangleBvhBase>(new TriangleBvh());
}

}